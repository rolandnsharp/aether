// src/audio_engine/compiler.js
// ============================================================================
// The "Surgical" Player Generator (Recursive AST Compiler)
//
// This module transforms an Abstract Syntax Tree (AST) generated by the tracer
// into a high-performance, stateful JavaScript `update` function for a Player.
// This is a core component of Phase 2, enabling JIT compilation for audio synthesis.
// ============================================================================

// Assumed Global State:
// - `globalThis.STATE_ARRAY`: A SharedArrayBuffer (Float64Array) holding all player states.
// - `globalThis.SAMPLE_RATE`: The global audio sample rate.
// - `globalThis.dt`: Derived from SAMPLE_RATE (1 / SAMPLE_RATE).

const MathFunctions = {
  sin: 'Math.sin',
  mul: '*' ,
  add: '+',
  pow: 'Math.pow',
  // Future: Add other Math functions and potentially custom DSP operators.
};

/**
 * Recursively generates JavaScript code snippets for a given AST node.
 * During traversal, it identifies oscillators and collects necessary information
 * for state management and phase updates.
 * 
 * This function is the heart of the code generation, transforming symbolic
 * mathematical operations into executable JavaScript.
 * 
 * @param {object} node - The current AST node being processed.
 * @param {object} context - An object holding mutable compiler state:
 *   - `oscillatorPhases`: Array to store global state indices for each discovered oscillator.
 *   - `phaseUpdates`: Array to store generated JavaScript code for phase accumulation.
 *   - `warnings`: Array to collect messages about unsupported AST nodes or operators.
 * @returns {string} The JavaScript code snippet representing the calculation of this node.
 */
function _generateNodeCode(node, context) {
  const { oscillatorPhases, phaseUpdates, warnings } = context;
  
  // Handle the 't' parameter, representing global time.
  // For compiled stateful players, `t` isn't directly used in calculations,
  // but its presence in the AST guides stateful code generation.
  if (node.type === 'param' && node.name === 't') {
    return '(currentT)'; // Placeholder: `currentT` is supplied by Conductor if needed for fallback f(t).
  } 
  // Handle literal number values (e.g., 440, 2, 5).
  // These are directly inserted into the generated code.
  else if (node.type === 'literal') {
    return node.value.toString();
  } 
  // Handle symbolic operations (e.g., add, mul, sin, pow).
  else if (node.type === 'op') {
    const op = node.op;
    // Recursively generate code for all arguments of the current operation.
    const args = node.args.map(arg => _generateNodeCode(arg, context));

    switch (op) {
      case 'add':
        // Generates `(arg1 + arg2 + ...)`
        return `(${args.join(' + ')})`;
      case 'mul':
        // Generates `(arg1 * arg2 * ...)`
        return `(${args.join(' * ')})`;
      case 'sin':
        // --- Core Oscillator JIT Compilation Logic ---
        // Each 'sin' node is treated as an oscillator and requires a dedicated phase state.
        
        // Stable State Slot Allocation:
        // We assign a unique offset within the player's 16-slot state block.
        // The `oscillatorPhases.length` provides a stable, sequential index.
        const phaseOffset = oscillatorPhases.length;
        // The global index in `globalThis.STATE_ARRAY` for this oscillator's phase.
        const phaseIndex = `baseIdx + ${phaseOffset}`; 
        oscillatorPhases.push(phaseIndex); // Record for compiler's awareness

        // Extract Frequency for Phase Accumulation (V1 Limitation):
        // For Phase 2 V1, we still need to explicitly find the frequency
        // by pattern matching `mul(t, freq)` directly within the `sin`'s argument.
        // A more advanced compiler (Phase 2, V2) would use symbolic evaluation
        // to derive this frequency from arbitrary nested ASTs.
        let freqValue = 0;
        if (node.args[0]?.type === 'op' && node.args[0]?.op === 'mul' &&
            node.args[0]?.args[0]?.type === 'param' && node.args[0]?.args[0]?.name === 't' &&
            node.args[0]?.args[1]?.type === 'literal') {
          freqValue = node.args[0].args[1].value;
        } else {
          // For FM, the frequency input to `sin` will be a nested AST.
          // The generated `deltaCode` below is a placeholder and will be more complex
          // once the compiler can dynamically evaluate `modulator_output`.
          // For now, if not `mul(t, freq)`, `freqValue` remains 0 (silent).
          warnings.push(`Complex sin argument at offset ${phaseOffset}. Assuming fixed frequency for now. Full FM JIT requires further compiler development.`);
        }

        // Generate Phase Accumulation Code:
        // This code updates the oscillator's phase for the *next* sample.
        // `globalThis.SAMPLE_RATE` is used to derive `delta`.
        const deltaCode = `${freqValue} / globalThis.SAMPLE_RATE`;
        phaseUpdates.push(`state[${phaseIndex}] = (state[${phaseIndex}] + (${deltaCode})) % 1.0;`);

        // Return Code for Sine Calculation:
        // This code calculates the sine value using the *current* phase state.
        return `Math.sin(state[${phaseIndex}] * 2 * Math.PI)`;
        
      case 'pow':
        // Generates `Math.pow(base, exponent)`
        return `Math.pow(${args[0]}, ${args[1]})`;
      
      // Future: Add more supported mathematical operations here.
      default:
        // If an operator is not supported, generate silence and a warning.
        warnings.push(`Unsupported operator: ${op}`);
        return '0';
    }
  }
  // If the node type itself is unknown, generate silence and a warning.
  warnings.push('Unknown AST node type.');
  return '0';
}

/**
 * The main compiler function. Takes an AST and a base state index,
 * and returns a JIT-compiled, stateful update function.
 * 
 * @param {object} ast - The Abstract Syntax Tree generated by `tracer.js`.
 * @param {number} baseStateIndex - The starting index in `globalThis.STATE_ARRAY`
 *                                  where this player's 16 state slots are reserved.
 * @returns {function(Float64Array, number, number)} A stateful update function:
 *          `function(globalState, baseIdx, dt) => sample`
 */
function compile(ast, baseStateIndex) {
  console.log('[Compiler] Compiling AST...');
  const context = { 
    oscillatorPhases: [], // Collects indices of all oscillators discovered in this AST.
    phaseUpdates: [],    // Collects JavaScript snippets for phase accumulation.
    warnings: []         // Collects warnings about unsupported operations.
  };
  
  // First pass: Traverse the AST to generate the core calculation code
  // and collect all phase update instructions.
  const expressionCode = _generateNodeCode(ast, context);
  
  // Construct the full generated function body string.
  // This function will be `new Function`'d to create the hot update loop.
  let generatedFunctionBody = 
    `const state = globalState;\n` + // Reference to the global state array
    `const baseIdx = baseStateIndex;\n` + // Player's base offset into the state array
    `let output = 0;\n` + // Variable to hold the final sample output

    // 1. Calculate the current output based on the current state (phases)
    `output = ${expressionCode};\n` +

    // 2. Update the state (phases) for the *next* sample
    context.phaseUpdates.join('\n') + '\n' +

    // 3. Return the calculated sample
    `return output;`;

  // Log any warnings generated during AST traversal.
  if (context.warnings.length > 0) {
    console.warn(`[Compiler] Warnings during compilation: ${context.warnings.join('; ')}`);
  }
  
  console.log('[Compiler] Generated Function Body (for ID @ baseIdx: '+ baseStateIndex +'):\n', generatedFunctionBody);

  // JIT compile the generated function body into an executable JavaScript function.
  // This function is highly optimized as it directly manipulates the state array
  // and avoids repeated AST traversals or object allocations per sample.
  const statefulUpdate = new Function('globalState', 'baseStateIndex', generatedFunctionBody);

  console.log(`[Compiler] Compiled stateful player for base index ${baseStateIndex}.`);
  return statefulUpdate;
}

module.exports = { compile };
